//Predefined parameters
var CLOUD_FILTER = 50;
var CLD_PRB_THRESH = 30;
var NIR_DRK_THRESH = 0.15;
var CLD_PRJ_DIST = 1;
var BUFFER = 55;

// Geometrie


//Load S2 cloud probability collection
var s2_cloudless_col = ee.ImageCollection('COPERNICUS/S2_CLOUD_PROBABILITY')
        .filterBounds(point)
        .filterDate('2017-03-28','2020-11-30');
print('Cloud probability collection:',s2_cloudless_col);        

//Load S2 collection
var filtered = S2.filterDate('2017-03-28','2020-11-30')
.filterBounds(point)
.filter(ee.Filter.lte('CLOUDY_PIXEL_PERCENTAGE', 50));
print('Filtered collection:',filtered);

//Join the collections 
var col = ee.ImageCollection(ee.Join.saveFirst('s2cloudless').apply
({'primary': filtered,
    'secondary': s2_cloudless_col,
    'condition': ee.Filter.equals({
    'leftField': 'system:index',
    'rightField': 'system:index'
    })
  }));
print('Joined collection:',col);

//Define cloud mask functions
function add_cloud_bands(img){
  //Get s2cloudless image, subset the probability band.
  var cld_prb = ee.Image(img.get('s2cloudless')).select('probability');
  
  //Condition s2cloudless by the probability threshold value.
  var is_cloud = cld_prb.gt(CLD_PRB_THRESH).rename('clouds');
  
  //Add the cloud probability layer and cloud mask as image bands.
  return img.addBands(ee.Image([cld_prb, is_cloud]));
}  

function add_shadow_bands(img){
  //Identify water pixels from the SCL band.
  var not_water = img.select('SCL').neq(6);
  
  //Identify dark NIR pixels that are not water (potential cloud shadow pixels).
  var SR_BAND_SCALE = 1e4;
  var dark_pixels = img.select('B8').lt(NIR_DRK_THRESH*SR_BAND_SCALE).multiply(not_water).rename('dark_pixels');
  
  //Determine the direction to project cloud shadow from clouds (assumes UTM projection).
  var shadow_azimuth = ee.Number(90).subtract(ee.Number(img.get('MEAN_SOLAR_AZIMUTH_ANGLE')));
  
  //Project shadows from clouds for the distance specified by the CLD_PRJ_DIST input.
  var cld_proj = img.select('clouds').directionalDistanceTransform(shadow_azimuth, CLD_PRJ_DIST*10)
  .reproject({'crs': img.select(0).projection(), 'scale': 100})
  .select('distance')
  .mask()
  .rename('cloud_transform');

  //Identify the intersection of dark pixels with cloud shadow projection.
  var shadows = cld_proj.multiply(dark_pixels).rename('shadows');

  //Add dark pixels, cloud projection, and identified shadows as image bands.
  return img.addBands(ee.Image([dark_pixels, cld_proj, shadows]));
}

function add_cld_shdw_mask(img){
  //Add cloud component bands.
  var img_cloud = add_cloud_bands(img);

  //Add cloud shadow component bands.
  var img_cloud_shadow = add_shadow_bands(img_cloud);

  //Combine cloud and shadow mask, set cloud and shadow as value 1, else 0.
  var is_cld_shdw0 = img_cloud_shadow.select('clouds').add(img_cloud_shadow.select('shadows')).gt(0);

  //Remove small cloud-shadow patches and dilate remaining pixels by BUFFER input.
  //20 m scale is for speed, and assumes clouds don't require 10 m precision.
  var is_cld_shdw = is_cld_shdw0.focal_min(2).focal_max(BUFFER*2/20)
  .reproject({'crs': img.select([0]).projection(), 'scale': 20})
  .rename('cloudmask');

  //Add the final cloud-shadow mask to the image.
  //return img_cloud_shadow.addBands(is_cld_shdw);
  return img.addBands(is_cld_shdw).updateMask(is_cld_shdw.eq(0));
}

//Define NDVI function
function addNDVI(image) {
  return image.addBands(image.normalizedDifference(['B8', 'B4']).rename('ndvi'));
  }
  
//Define EVI function
function addEVI(image) {
  var evi = image.expression('2.5 * ((NIR - RED) / (NIR + 6 * RED - 7.5 * BLUE + 1))', {
    'NIR' : image.select('B8'),
    'RED' : image.select('B4'),
    'BLUE': image.select('B2')
  }).float();
  return image.addBands(evi.rename('evi'));
}
  
//Add cloudmask and ndvi bands to the final collection  
var cl = col.map(add_cld_shdw_mask)
.map(addNDVI)
.map(addEVI);
print('Final collection s2cloudless:',cl);

//Zoom to the specific area
Map.setCenter(14.17,50.44, 12);

//Set color palette for ndvi band
var ndvi_palette = ['d73027','f46d43','fdae61','fee08b','ffffbf',
'd9ef8b','a6d96a','66bd63','1a9850','006837'];

//Add layers to the map
var img1 = cl.first();
Map.addLayer(img1, rgbVisParam, 'RGB');
Map.addLayer(img1, {bands:'ndvi', min:0, max:1, palette:ndvi_palette}, 'ndvi_coll');
//Map.addLayer(img1, {bands:'evi', min:-1, max:1, palette:ndvi_palette}, 'evi_coll');
//Map.addLayer(img1,{bands:'cloudmask'},'cloudmask');


//// Adjust data for export
var triplets = cl.map(function(image) {
  return image.select('ndvi').reduceRegions({
    collection: point, 
    reducer: ee.Reducer.mean().setOutputs(['ndvi']), 
    scale: 10,
  })
  .map(function(feature){
    var ndvi = ee.List([feature.get('ndvi'), -9999])
      .reduce(ee.Reducer.firstNonNull())
    return feature.set({'ndvi': ndvi, 'imageID': image.id()})
    })
  // .filter(ee.Filter.neq('ndvi', null))
  //   .map(function(feature) {
  //     return feature.set({'imageID': image.id()})
  // })
}).flatten();
print('Triplets: ', triplets);

var format = function(table, rowId, colId) {
  var rows = table.distinct(rowId); 
  var joined = ee.Join.saveAll('matches').apply({
    primary: rows, 
    secondary: table, 
    condition: ee.Filter.equals({
      leftField: rowId, 
      rightField: rowId
    })
  });
         
  return joined.map(function(row) {
      var values = ee.List(row.get('matches'))
        .map(function(feature) {
          feature = ee.Feature(feature);
          return [feature.get(colId), feature.get('ndvi')];
        });
      return row.select([rowId]).set(ee.Dictionary(values.flatten()));
    });
};
var sentinelResults = format(triplets, 'id', 'imageID');

print('S2 merged triplets:',sentinelResults);

// There are multiple image granules for the same date processed from the same orbit
// Granules overlap with each other and since they are processed independently
// the pixel values can differ slightly. So the same pixel can have different NDVI 
// values for the same date from overlapping granules.
// So to simplify the output, we can merge observations for each day
// And take the max ndvi value from overlapping observations
var merge = function(table, rowId) {
  return table.map(function(feature) {
    var id = feature.get(rowId)
    var allKeys = feature.toDictionary().keys().remove(rowId)
    var substrKeys = ee.List(allKeys.map(function(val) { 
        return ee.String(val).slice(0,8)}
        ))
    var uniqueKeys = substrKeys.distinct()
    var pairs = uniqueKeys.map(function(key) {
      var matches = feature.toDictionary().select(allKeys.filter(ee.Filter.stringContains('item', key))).values()
      var val = matches.reduce(ee.Reducer.max())
      return [key, val]
    })
    return feature.select([rowId]).set(ee.Dictionary(pairs.flatten()))
  })
}
var sentinelMerged = merge(sentinelResults, 'id');

print("S merged:", sentinelMerged);

//Generate Time-Series plot
var plotNDVI = ui.Chart.image.seriesByRegion({
      imageCollection: cl.select('ndvi'), 
      regions: point,
      reducer: ee.Reducer.mean(),
      scale: 10,
      // xProperty:'system:time_start',
      seriesProperty:'system:index'})
              .setOptions({
                title: 'NDVI time series',
                interpolateNulls: true,
                lineWidth: 1,
                pointSize: 3,
                hAxis: {title: 'Date'},
                vAxis: {title: 'NDVI'}
      });
print(plotNDVI);


Export.table.toDrive({
    collection: sentinelResults,
    description: 'NDVI_ts_sentinelResults',
    folder: 'earthengine',
    fileNamePrefix: 'NDVI_ts_sentinelMerged',
    fileFormat: 'CSV'
})

Export.table.toDrive({
    collection: sentinelMerged,
    description: 'NDVI_ts_sentinelMerged',
    folder: 'earthengine',
    fileNamePrefix: 'NDVI_ts_sentinelMerged',
    fileFormat: 'CSV'
})

//Export charts to CSV
//Export.table.toDrive({collection: with_ndvi,description:'NDVI_export',folder:'GEE',selectors:'Date,NDVI'});
